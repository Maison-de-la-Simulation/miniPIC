# __________________________________________
#
# Python script to plot the profiler data
#
# __________________________________________

# Import the modules
import struct
import sys
import numpy as np
import glob
from matplotlib import *
from matplotlib.pyplot import *
import math
# ______________________________________________________________________________
# RCParams - personalize the figure output

rcParams['figure.facecolor'] = 'w'
rcParams['font.size'] = 15
rcParams['xtick.labelsize'] = 15
rcParams['ytick.labelsize'] = 15
rcParams['axes.labelsize'] = 15

rcParams['xtick.major.size'] = 10
rcParams['ytick.major.size'] = 10

rcParams['xtick.minor.size'] = 5
rcParams['ytick.minor.size'] = 5

rcParams['axes.linewidth'] = 1.5

rcParams['xtick.major.width'] = 2
rcParams['ytick.major.width'] = 2

rcParams['xtick.minor.width'] = 1.5
rcParams['ytick.minor.width'] = 1.5

rcParams["figure.figsize"] = (10,15)

colors = ['C0', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 
          'C8', 'C9', 'C10', 'C11', 'C12', 'C13', 'C14',
          'C15', 'C16', 'C17']

# ______________________________________________________________________________
# Read command line arguments

# function to read the command line arguments
def read_command_line_arguments():

    args = {}

    if len(sys.argv) > 1:
        args["path"] = sys.argv[1]
    else:
        sys.exit("Please, specify a valid path to a binary file as a first command line argument.")

    return args


# ______________________________________________________________________________

# Data stucture to store an event containing:
# - a start timer 
# - a stop timer
# - an occurence code
class Event:
    def __init__(self, start, stop, code):
        self.start = start
        self.stop = stop
        self.code = code

# Function to read the profiler data `profiler.bin` generated by mini-pic
# The file is built as follow:
# - the first parameter is the number of threads
# Then for each thread:
# - the first parameter is the number of events
# - for each event, put in the event data structure:
#   - the first parameter is the number of samples
# Use the module `struct` to read the binary file
def read_profiler_data(filename):
    with open(filename, 'rb') as f:
        data = f.read()
    i = 0
    nb_threads = struct.unpack('i', data[i:i+4])[0]; i += 4
    events = []
    for t in range(nb_threads):
        nb_events = struct.unpack('i', data[i:i+4])[0]
        i += 4
        thread_events = []
        for e in range(nb_events):
            start = struct.unpack('d', data[i:i+8])[0]
            i += 8
            stop = struct.unpack('d', data[i:i+8])[0]
            i += 8
            code = struct.unpack('i', data[i:i+4])[0]
            i += 4
            thread_events.append(Event(start, stop, code))

        events.append(thread_events)
    return events

# ______________________________________________________________________________
# main function
if __name__ == "__main__":

    occurences = []
    occurences.append("Reset current")
    occurences.append("Evolve bin")
    occurences.append("Evolve patch")
    occurences.append("Exchange")
    occurences.append("Projection internal")
    occurences.append("Projection borders")
    occurences.append("Currentbc")
    occurences.append("Maxwell")
    occurences.append("Diagnostics")

    numbc = [-0.225,-0.175,-0.125,-0.075,0.075,0.125,0.175,0.225,0.225]

    # Read the command line arguments
    args = read_command_line_arguments()

    # Read the profiler data
    events = read_profiler_data(args["path"] + "/profiler.bin")

    nb_threads = len(events)


    # Print number of threads and events
    print("Number of threads: ", nb_threads)
    for t in range(nb_threads):
        print("Number of events in thread ", t, ": ", len(events[t]))

    # Plot the profiler data
    fig, ax = subplots(figsize=(30, 20))
    for t in range(len(events)):
        for e in range(len(events[t])):
            start = events[t][e].start
            stop = events[t][e].stop
            code = events[t][e].code
            # print("t = ", t, ", e = ", e, ", start = ", start, ", stop = ", stop, ", code = ", code, sep="")
            ax.plot([start, stop], [t+numbc[code], t+numbc[code]],solid_capstyle='butt', color=colors[code], linewidth=20)

    # Create the labels for the legend
    for i, occurence in enumerate(occurences):
        ax.plot([0,0], [0,0], colors[i], label=occurence)


    # Plot the legend
    ax.set_xlabel("Time (s)", fontsize=30, fontweight='bold')
    ax.set_ylabel("Thread", fontsize=30, fontweight='bold')
    ax.set_title("Profiler data : Case beam", fontsize=30, fontweight='bold')

    # Shrink current axis by 20%
    box = ax.get_position()
    ax.set_position([box.x0, box.y0, box.width, box.height])
        
    # Put a legend to the right of the current axis
    leg = ax.legend(loc='center left', fancybox=True, shadow=True,
                 fontsize=20, bbox_to_anchor=(1, 0.5))

    # change the line width for the legend
    for line in leg.get_lines():
        line.set_linewidth(16.0)
 
    # Grid line width
    ax.grid(which='major', linestyle='-', linewidth='0.5')
    ax.grid(which='minor', linestyle=':', linewidth='0.5')
    ax.minorticks_on()
    ax.tick_params(axis='both',labelsize = 30)

    new_list = range(math.floor(-0.5), math.ceil(len(events) - 0.5)+1)
    ax.set_yticks(new_list)
    ax.set_ylim(-0.5, len(events) - 0.5)
    #ax.set_xlim(0, 250)

    #ax.set_dash_capstyle('butt')

    ax.grid()
    fig.tight_layout()
    fig.savefig("profiler.png")

    show()